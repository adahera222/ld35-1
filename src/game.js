// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, filter, flatten, Key, FPS, RES, DIRS, remove, degToRad, Point, Stage, Layer, Centerable, Character, drawArc, drawCircle, drawSemicircle, drawTriangle, R, pick, randomColor, Behavior, Snuffle, Shrine, Blok, makeWall, isInWall, Map, FlowerStack, Flower, Game;
  ref$ = require('prelude-ls'), map = ref$.map, filter = ref$.filter, flatten = ref$.flatten;
  Key = Mousetrap;
  FPS = 30;
  RES = 40;
  DIRS = [['vy', -1, 'up'], ['vx', 1, 'right'], ['vy', 1, 'down'], ['vx', -1, 'left']];
  remove = function(list, member){
    var ii;
    ii = list.indexOf(member);
    if (-1 < ii) {
      return list.splice(ii, 1);
    }
  };
  degToRad = function(it){
    return it * (Math.PI / 180);
  };
  Point = (function(){
    Point.displayName = 'Point';
    var prototype = Point.prototype, constructor = Point;
    function Point(x, y){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.x = x;
      this$.y = y;
      this$.clamped = bind$(this$, 'clamped', prototype);
      this$.midpoint = bind$(this$, 'midpoint', prototype);
      this$.dist = bind$(this$, 'dist', prototype);
      this$.angle = bind$(this$, 'angle', prototype);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.angle = function(oo){
      var dy, dx;
      dy = oo.y - this.y;
      dx = oo.x - this.x;
      return Math.atan2(dy, dx);
    };
    prototype.dist = function(oo){
      return Math.sqrt(Math.pow(this.x - oo.x, 2) + Math.pow(this.y - oo.y, 2));
    };
    prototype.midpoint = function(oo, percent){
      var ang, factor, dx, dy;
      percent == null && (percent = 0.5);
      ang = this.angle(oo);
      factor = percent * this.dist(oo);
      dx = factor * Math.cos(ang);
      dy = factor * Math.sin(ang);
      return new Point(this.x + dx, this.y + dy);
    };
    prototype.clamped = function(){
      return new Point(~~this.x, ~~this.y);
    };
    return Point;
  }());
  Stage = (function(){
    Stage.displayName = 'Stage';
    var prototype = Stage.prototype, constructor = Stage;
    function Stage(){
      this.canvas = document.getElementById('canvas');
      this.ctx = this.canvas.getContext('2d');
      this.ctx.mozImageSmoothingEnabled = false;
      this.ctx.webkitImageSmoothingEnabled = false;
      this.children = [];
    }
    prototype.clear = function(){
      return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };
    prototype.drawLabel = function(x, y, text){
      this.ctx.font = '16pt Arial';
      this.ctx.fillStyle = 'white';
      return this.ctx.fillText(text, x, y);
    };
    prototype.add = function(c){
      return this.children.push(c);
    };
    prototype.remove = function(c){
      return remove(this.children, c);
    };
    prototype.draw = function(){
      var this$ = this;
      this.clear();
      return map(function(it){
        return it.draw(this$.ctx);
      }, this.children);
    };
    return Stage;
  }());
  Layer = (function(){
    Layer.displayName = 'Layer';
    var prototype = Layer.prototype, constructor = Layer;
    function Layer(){
      this.set = bind$(this, 'set', prototype);
      this.clear = bind$(this, 'clear', prototype);
      this.remove = bind$(this, 'remove', prototype);
      this.add = bind$(this, 'add', prototype);
      this.draw = bind$(this, 'draw', prototype);
      this.children = [];
    }
    prototype.draw = function(ctx){
      return map(function(it){
        return it.draw(ctx);
      }, this.children);
    };
    prototype.add = function(c){
      return this.children.push(c);
    };
    prototype.remove = function(c){
      return remove(this.children, c);
    };
    prototype.clear = function(){
      return this.children = [];
    };
    prototype.set = function(it){
      return this.children = [it];
    };
    return Layer;
  }());
  Centerable = {
    center: function(){
      return Point(this.x + this.width / 2, this.y + this.height / 2);
    },
    moveCenterTo: function(point){
      this.x = point.x - this.width / 2;
      return this.y = point.y - this.height / 2;
    }
  };
  Character = (function(){
    Character.displayName = 'Character';
    var prototype = Character.prototype, constructor = Character;
    importAll$(prototype, arguments[0]);
    Character.all = [];
    Character.tagged = function(tag){
      return this.all.filter(function(x){
        return in$(tag, x.tags);
      });
    };
    Character.emptyAll = function(){
      return this.all = [];
    };
    function Character(x, y, size, drawable){
      this.x = x;
      this.y = y;
      this.size = size != null ? size : RES;
      this.intersect = bind$(this, 'intersect', prototype);
      this.exit = bind$(this, 'exit', prototype);
      constructor.all.push(this);
      this.tags = [];
      this.visible = true;
      this.ticks = [];
      this.addTick(this.physics2D);
      this.graphics = drawable || Snuffle('#aaa', '#999', '#666');
      this.width = this.height = this.size;
      this.vx = 0;
      this.vy = 0;
      this.lastPos = Point(0, 0);
      this.lastDir = DIRS[0];
    }
    prototype.physics2D = function(){
      this.x += this.vx;
      if (this.vx && isInWall(this)) {
        this.x -= this.vx;
      }
      this.y += this.vy;
      if (this.vy && isInWall(this)) {
        this.y -= this.vy;
      }
      return this.lastPos = Point(this.x, this.y);
    };
    prototype.exit = function(){
      return remove(constructor.all, this);
    };
    prototype.draw = function(ctx){
      var cx, cy;
      if (!this.visible) {
        return;
      }
      ctx.save();
      cx = this.x;
      cy = this.y;
      if (this.alpha) {
        ctx.globalAlpha = this.alpha;
      }
      if (this.rotation) {
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.rotate((Math.PI / 180) * this.rotation);
        this.x = -(this.width / 2);
        this.y = -(this.height / 2);
      }
      this.graphics.draw(ctx, Point(this.x, this.y));
      ctx.restore();
      this.x = cx;
      return this.y = cy;
    };
    prototype.tick = function(){
      var i$, ref$, len$, tt, results$ = [];
      for (i$ = 0, len$ = (ref$ = this.ticks).length; i$ < len$; ++i$) {
        tt = ref$[i$];
        if ('remove-me' === tt.call(this)) {
          results$.push(this.removeTick(tt));
        }
      }
      return results$;
    };
    prototype.addTick = function(f){
      return this.ticks.push(f);
    };
    prototype.removeTick = function(f){
      return remove(this.ticks, f);
    };
    prototype.intersect = function(oo){
      if (!oo) {
        return;
      }
      return this.x <= oo.x + oo.width && oo.x <= this.x + this.width && this.y <= oo.y + oo.height && oo.y <= this.y + this.height;
    };
    prototype.dist = function(oo){
      var mc, oc;
      mc = {
        x: this.x + this.width / 2,
        y: this.y + this.height / 2
      };
      oc = {
        x: oo.x + oo.width / 2,
        y: oo.y + oo.height / 2
      };
      return Math.sqrt(Math.pow(mc.x - oc.x, 2) + Math.pow(mc.y - oc.y, 2));
    };
    return Character;
  }(Centerable));
  drawArc = function(color, start, radius, ctx, rads){
    ctx.beginPath();
    ctx.arc(start.x, start.y, radius, Math.PI, Math.PI + rads);
    ctx.closePath();
    ctx.fillStyle = color;
    return ctx.fill();
  };
  drawCircle = function(color, start, radius, ctx){
    return drawArc(color, start, radius, ctx, 2 * Math.PI);
  };
  drawSemicircle = function(color, start, radius, ctx){
    return drawArc(color, start, radius, ctx, Math.PI);
  };
  drawTriangle = function(color, start, height, ctx, width){
    if (!width) {
      width = height;
    }
    ctx.fillStyle = color;
    ctx.moveTo(start.x, start.y);
    ctx.beginPath();
    ctx.lineTo(start.x + width / 2, start.y + height);
    ctx.lineTo(start.x - width / 2, start.y + height);
    ctx.lineTo(start.x, start.y);
    ctx.closePath();
    return ctx.fill();
  };
  R = function(it){
    return ~~(it * Math.random());
  };
  pick = function(it){
    return it[R(it.length)];
  };
  randomColor = function(){
    var palette;
    palette = '0123456789ABCDEF';
    return '#' + pick(palette) + pick(palette) + pick(palette);
  };
  Behavior = (function(){
    Behavior.displayName = 'Behavior';
    var prototype = Behavior.prototype, constructor = Behavior;
    function Behavior(method, tape){
      this.method = method;
      this.tape = tape != null ? tape : null;
      this.perform = bind$(this, 'perform', prototype);
      this.pointer = 0;
    }
    prototype.perform = function(target){
      if (this.pointer > this.tape.length) {
        return null;
      }
      target[this.method](this.tape[this.pointer]);
      return this.pointer++;
    };
    return Behavior;
  }());
  Snuffle = (function(){
    Snuffle.displayName = 'Snuffle';
    var prototype = Snuffle.prototype, constructor = Snuffle;
    function Snuffle(nose, band, body, height){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.nose = nose;
      this$.band = band;
      this$.body = body;
      this$.height = height != null ? height : RES;
      this$.draw = bind$(this$, 'draw', prototype);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.draw = function(ctx, pos){
      pos = Point(pos.x + this.height / 2, pos.y);
      drawTriangle(this.body, pos, this.height, ctx);
      drawTriangle(this.band, pos, 0.4 * this.height, ctx);
      return drawTriangle(this.nose, pos, 0.3 * this.height, ctx);
    };
    return Snuffle;
  }());
  Shrine = (function(){
    Shrine.displayName = 'Shrine';
    var prototype = Shrine.prototype, constructor = Shrine;
    function Shrine(moon, wedge, size){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.moon = moon;
      this$.wedge = wedge;
      this$.size = size != null
        ? size
        : 4 * RES;
      this$.draw = bind$(this$, 'draw', prototype);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.draw = function(ctx, pos){
      pos = Point(pos.x + this.size / 2, pos.y);
      drawSemicircle(this.moon, pos, this.size / 2, ctx);
      return drawTriangle(this.wedge, pos, -this.size / 2, ctx, this.size);
    };
    return Shrine;
  }());
  Blok = (function(){
    Blok.displayName = 'Blok';
    var prototype = Blok.prototype, constructor = Blok;
    function Blok(hour, decade, instant, x, y, height){
      this.hour = hour;
      this.decade = decade;
      this.instant = instant;
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.height = height != null ? height : RES;
      this.draw = bind$(this, 'draw', prototype);
      this.center = bind$(this, 'center', prototype);
      this.width = this.height;
    }
    prototype.center = function(){
      var h2;
      h2 = ~~(this.height / 2);
      return {
        x: this.x + h2,
        y: this.y + h2
      };
    };
    prototype.pos = Point(Blok.x, Blok.y);
    prototype.draw = function(ctx){
      var h2, h4;
      ctx.save();
      ctx.fillStyle = this.decade;
      ctx.fillRect(this.x, this.y, this.height, this.height);
      h2 = ~~(this.height / 2);
      this.drawTriangle(this.hour, this.center(), {
        x: h2,
        y: h2
      }, {
        x: -h2,
        y: h2
      }, ctx);
      this.drawTriangle(this.hour, this.center(), {
        x: h2,
        y: -h2
      }, {
        x: -h2,
        y: -h2
      }, ctx);
      if (this.instant) {
        h4 = ~~(this.height / 4);
        drawCircle(this.instant, this.center(), h4, ctx);
      }
      return ctx.restore();
    };
    prototype.drawCorners = function(ctx){
      var h4, h2;
      h4 = ~~(this.height / 4);
      h2 = ~~(this.height / 2);
      this.drawTriangle(this.hour, {
        x: this.x,
        y: this.y
      }, {
        x: h4,
        y: 0
      }, {
        x: 0,
        y: h2
      });
      this.drawTriangle(this.hour, {
        x: this.x + this.height,
        y: this.y
      }, {
        x: -h4,
        y: 0
      }, {
        x: 0,
        y: h2
      });
      this.drawTriangle(this.hour, {
        x: this.x,
        y: this.y + this.height
      }, {
        x: h4,
        y: 0
      }, {
        x: 0,
        y: -h2
      });
      return this.drawTriangle(this.hour, {
        x: this.x + this.height,
        y: this.y + this.height
      }, {
        x: -h4,
        y: 0
      }, {
        x: 0,
        y: -h2
      });
    };
    prototype.drawTriangle = function(fill, start, diff1, diff2, ctx){
      ctx.moveTo(start.x, start.y);
      ctx.beginPath();
      ctx.lineTo(start.x + diff1.x, start.y + diff1.y);
      ctx.lineTo(start.x + diff2.x, start.y + diff2.y);
      ctx.lineTo(start.x, start.y);
      ctx.closePath();
      ctx.fillStyle = fill;
      return ctx.fill();
    };
    return Blok;
  }());
  makeWall = function(){
    var colors, centerColors, i$, x, lresult$, j$, y, blok, results$ = [];
    colors = ['#aca', '#bdb', '#beb', '#ada', '#cec', '#cfc'];
    centerColors = ['#ccc', '#cfc'];
    for (i$ = 0; i$ < 20; ++i$) {
      x = i$;
      lresult$ = [];
      for (j$ = 0; j$ < 15; ++j$) {
        y = j$;
        lresult$.push(blok = new Blok(pick(colors), pick(colors), pick(centerColors), x * RES, y * RES));
      }
      results$.push(lresult$);
    }
    return results$;
  };
  isInWall = function(oo){
    var walls, collisions;
    walls = window.game.world.bg.children[0].walls;
    collisions = filter(oo.intersect, walls);
    if (collisions.length > 0) {
      return true;
    }
  };
  Map = (function(){
    Map.displayName = 'Map';
    var prototype = Map.prototype, constructor = Map;
    function Map(mapping){
      var colors, centerColors, m, res$, i$, x, lresult$, j$, y, blok, this$ = this instanceof ctor$ ? this : new ctor$;
      this$.mapping = mapping;
      this$.draw = bind$(this$, 'draw', prototype);
      colors = ['#aca', '#bdb', '#beb', '#ada', '#cec', '#cfc'];
      centerColors = ['#ccc', '#cfc'];
      m = this$.mapping;
      res$ = [];
      for (i$ = 0; i$ < 20; ++i$) {
        x = i$;
        lresult$ = [];
        for (j$ = 0; j$ < 15; ++j$) {
          y = j$;
          m = this$.mapping[x][y];
          blok = new Blok(m[0], m[1], m[2], x * RES, y * RES);
          blok.solid = m[3];
          lresult$.push(blok);
        }
        res$.push(lresult$);
      }
      this$.cells = res$;
      this$.walls = filter(function(it){
        return it.solid === true;
      }, flatten(this$.cells));
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.draw = function(ctx){
      return map(function(it){
        return it.draw(ctx);
      }, flatten(this.cells));
    };
    return Map;
  }());
  FlowerStack = (function(){
    FlowerStack.displayName = 'FlowerStack';
    var prototype = FlowerStack.prototype, constructor = FlowerStack;
    function FlowerStack(size){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      size == null && (size = RES * 2);
      this$.draw = bind$(this$, 'draw', prototype);
      this$.flowers = [Flower.random(size), Flower.random(~~(size * 0.8)), Flower.random(~~(size * 0.5))];
      console.log(this$.flowers);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.draw = function(ctx, pos){
      return map(function(it){
        return it.draw(ctx, pos);
      }, this.flowers);
    };
    return FlowerStack;
  }());
  Flower = (function(){
    Flower.displayName = 'Flower';
    var prototype = Flower.prototype, constructor = Flower;
    Flower.colors = ['black', 'red', 'green', 'blue', 'purple', 'orange', 'white', 'cyan'];
    Flower.random = function(size){
      var color, petals, s4, cp1, cp2;
      size == null && (size = RES);
      color = pick(Flower.colors);
      petals = 3 * (R(8) + 1);
      s4 = ~~(size / 4);
      cp1 = Point(R(size / 3), R(size / 4) + s4);
      cp2 = Point(size - R(size / 2), R(size / 4) + s4);
      return Flower(color, petals, cp1, cp2, size);
    };
    function Flower(color, petals, cp1, cp2, size){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.color = color;
      this$.petals = petals;
      this$.cp1 = cp1;
      this$.cp2 = cp2;
      this$.size = size != null ? size : RES;
      this$.draw = bind$(this$, 'draw', prototype);
      this$.itos = bind$(this$, 'itos', prototype);
      this$.opacity = 0.3;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.itos = function(val, frac){
      frac == null && (frac = 1);
      return val * (this.size / frac);
    };
    prototype.draw = function(ctx, pos){
      var i$, to$, p;
      ctx.save();
      ctx.globalAlpha = this.opacity;
      ctx.fillStyle = this.color;
      ctx.translate(pos.x, pos.y);
      ctx.moveTo(0, 0);
      for (i$ = 0, to$ = this.petals; i$ < to$; ++i$) {
        p = i$;
        ctx.beginPath();
        ctx.bezierCurveTo(this.cp1.x, this.cp1.y, this.cp2.x, this.cp2.y, this.size, 0);
        ctx.bezierCurveTo(this.cp2.x, -this.cp2.y, this.cp1.x, -this.cp1.y, 0, 0);
        ctx.closePath();
        ctx.fill();
        ctx.rotate(degToRad(360 / this.petals));
      }
      return ctx.restore();
    };
    return Flower;
  }());
  Game = (function(){
    Game.displayName = 'Game';
    var prototype = Game.prototype, constructor = Game;
    function Game(width, height, fps){
      var i$, len$, solid, empty, mapping, ref$, mapping2, mapping3, this$ = this;
      this.width = width;
      this.height = height;
      this.fps = fps;
      this.loop = bind$(this, 'loop', prototype);
      this.screenSwap = bind$(this, 'screenSwap', prototype);
      this.frame = 0;
      this.pause = false;
      this.over = false;
      this.world = new Stage;
      this.world.add(new Layer);
      this.world.add(new Layer);
      this.world.add(new Layer);
      this.world.bg = this.world.children[0];
      this.world.ground = this.world.children[1];
      this.world.fg = this.world.children[2];
      Key.bind('space', function(){
        return this.pause = !this.pause;
      });
      Key.bind('a', function(){
        var s;
        s = new Character(10 * RES, 10 * RES, 4 * RES, Shrine('#39f', '#cc6'));
        return this$.world.ground.add(s);
      });
      Key.bind('z', function(){
        var f;
        f = new Character(this$.player.x, this$.player.y, 4 * RES, new FlowerStack);
        return this$.world.ground.add(f);
      });
      this.loopInstance = setInterval(this.loop, 1000 / this.fps);
      this.player = new Character(3 * RES, 3 * RES, RES, Snuffle('#aaa', '#000', '#aaa'));
      for (i$ = 0, len$ = DIRS.length; i$ < len$; ++i$) {
        (fn$.call(this, DIRS[i$]));
      }
      solid = ['black', 'black', 'white', true];
      empty = ['#eee', '#ddd', '#ddd', false];
      mapping = [[solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid]].concat([ref$ = [empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty], ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$]).concat([[solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid]]);
      this.world.bg.add(Map(mapping));
      this.world.fg.add(this.player);
      mapping = [[solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid]].concat([ref$ = [empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty], ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$]).concat([[solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid]]);
      mapping2 = [[solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid]].concat([ref$ = [empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty], ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$]).concat([ref$ = [solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid], ref$]);
      mapping3 = [[solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid]].concat([ref$ = [empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty], ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$, ref$]).concat([ref$ = [solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid, solid], ref$, ref$]);
      this.worldMap = [[mapping, mapping2, mapping3]];
      this.screen = Point(0, 0);
      function fn$(dd){
        var this$ = this;
        Key.bind(dd[2], function(){
          return this$.player[dd[0]] = 6 * dd[1];
        });
        Key.bind(dd[2], function(){
          return this$.player[dd[0]] = 0;
        }, 'keyup');
      }
    }
    prototype.screenSwap = function(){
      if (this.player.y < 0) {
        this.screen = Point(this.screen.x, this.screen.y - 1);
        this.world.bg.set(Map(this.worldMap[this.screen.x][this.screen.y]));
        this.player.y = this.height - this.player.height - 1;
      }
      if (this.player.y + this.player.height > this.height) {
        this.screen = Point(this.screen.x, this.screen.y + 1);
        this.world.bg.set(Map(this.worldMap[this.screen.x][this.screen.y]));
        return this.player.y = 1;
      }
    };
    prototype.loop = function(){
      var i$, ref$, len$, cc;
      if (this.pause) {
        return;
      }
      this.frame++;
      for (i$ = 0, len$ = (ref$ = Character.all).length; i$ < len$; ++i$) {
        cc = ref$[i$];
        if (cc != null) {
          cc.tick();
        }
      }
      this.screenSwap();
      this.world.draw();
      if (this.over) {
        this.world.drawLabel(300, 230, "GAME OVER");
        return this.world.drawLabel(260, 260, "push r to restart");
      }
    };
    return Game;
  }());
  window.game = new Game(800, 600, FPS);
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
